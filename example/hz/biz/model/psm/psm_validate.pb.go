// Code generated by protoc-gen-validator. DO NOT EDIT.
// versions:
// 	protoc-gen-validator v0.1.0
// source: psm.proto

package psm

import (
	other "a/b/c/biz/model/other"
	bytes "bytes"
	fmt "fmt"
	os "os"
	reflect "reflect"
	regexp "regexp"
	strconv "strconv"
	strings "strings"
	time "time"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = (*regexp.Regexp)(nil)
	_ = time.Nanosecond
)

func (m *IntValidate) Validate() error {
	if m.GetInt32Const() != int32(123) {
		return fmt.Errorf("field Int32Const not match const value, current value: %v", m.GetInt32Const())
	}
	if m.GetInt32Const() >= int32(132) {
		return fmt.Errorf("field Int32Const lt rule failed, current value: %v", m.GetInt32Const())
	}
	if m.GetInt32Const() > int32(1232) {
		return fmt.Errorf("field Int32Const le rule failed, current value: %v", m.GetInt32Const())
	}
	if m.GetSIntLt() >= int32(123) {
		return fmt.Errorf("field SIntLt lt rule failed, current value: %v", m.GetSIntLt())
	}
	if m.GetSFix32Lte() > int32(123) {
		return fmt.Errorf("field SFix32Lte le rule failed, current value: %v", m.GetSFix32Lte())
	}
	if m.GetUIntGt() <= uint32(123) {
		return fmt.Errorf("field UIntGt gt rule failed, current value: %v", m.GetUIntGt())
	}
	if m.Uint64Gte == nil {
		return fmt.Errorf("field uint64Gte not_nil rule failed")

	}
	if m.GetUint64Gte() < uint64(123) {
		return fmt.Errorf("field uint64Gte ge rule failed, current value: %v", m.GetUint64Gte())
	}
	_src := []uint32{uint32(123), uint32(456), uint32(789)}

	var _exist bool
	for _, src := range _src {
		if m.GetFix32In() == uint32(src) {
			_exist = true
			break
		}
	}
	if !_exist {
		return fmt.Errorf("field Fix32In in rule failed, current value: %v", m.GetFix32In())
	}
	_src1 := []uint64{uint64(123), uint64(456), uint64(789), uint64(m.GetSFix32Lte())}

	for _, src := range _src1 {
		if m.GetFix64Notin() == uint64(src) {
			return fmt.Errorf("field Fix64Notin not_in rule failed, current value: %v", m.GetFix64Notin())
		}
	}
	if m.GetReference() > int32(m.GetSIntLt()) {
		return fmt.Errorf("field Reference le rule failed, current value: %v", m.GetReference())
	}
	return nil
}

func (m *DoubleValidate) Validate() error {
	if m.GetDoubleConst() != float64(123.123) {
		return fmt.Errorf("field DoubleConst not match const value, current value: %v", m.GetDoubleConst())
	}
	if m.GetFloatLt() >= float32(123.312) {
		return fmt.Errorf("field FloatLt lt rule failed, current value: %v", m.GetFloatLt())
	}
	if m.GetDoubleLe() > float64(123.54) {
		return fmt.Errorf("field DoubleLe le rule failed, current value: %v", m.GetDoubleLe())
	}
	if m.GetDoubleGt() <= float64(123.76) {
		return fmt.Errorf("field DoubleGt gt rule failed, current value: %v", m.GetDoubleGt())
	}
	if m.GetDoubleGe() < float64(123.32) {
		return fmt.Errorf("field DoubleGe ge rule failed, current value: %v", m.GetDoubleGe())
	}
	_src := []float64{float64(123.9), float64(456.443), float64(789.232)}

	var _exist bool
	for _, src := range _src {
		if m.GetDoubleIn() == float64(src) {
			_exist = true
			break
		}
	}
	if !_exist {
		return fmt.Errorf("field DoubleIn in rule failed, current value: %v", m.GetDoubleIn())
	}
	_src1 := []float64{float64(123.234), float64(456.7654), float64(789.232), float64(m.GetDoubleLe())}

	for _, src := range _src1 {
		if m.GetDoubleNotin() == float64(src) {
			return fmt.Errorf("field DoubleNotin not_in rule failed, current value: %v", m.GetDoubleNotin())
		}
	}
	if m.GetReference() > float64(m.GetDoubleLe()) {
		return fmt.Errorf("field Reference le rule failed, current value: %v", m.GetReference())
	}
	return nil
}

func (m *BoolValidator) Validate() error {
	if m.GetBoolConst() != true {
		return fmt.Errorf("field BoolConst const rule failed, current value: %v", m.GetBoolConst())
	}
	if m.GetReference() != m.GetBoolConst() {
		return fmt.Errorf("field Reference const rule failed, current value: %v", m.GetReference())
	}
	return nil
}

func (m *StringValidate) Validate() error {
	_src := "asd"
	if m.GetStringConst() != _src {
		return fmt.Errorf("field StringConst not match const value, current value: %v", m.GetStringConst())
	}
	if len(m.GetStringMinSize()) < int(12) {
		return fmt.Errorf("field StringMinSize min_len rule failed, current value: %d", len(m.GetStringMinSize()))
	}
	if len(m.GetStringMaxSize()) > int(12) {
		return fmt.Errorf("field StringMaxSize max_len rule failed, current value: %d", len(m.GetStringMaxSize()))
	}
	_src1 := "[0-9A-Za-z]+"
	if ok, _ := regexp.MatchString(_src1, m.GetStringPattern()); !ok {
		return fmt.Errorf("field StringPattern pattern rule failed, current value: %v", m.GetStringPattern())
	}
	_src2 := "asd"
	if !strings.HasPrefix(m.GetStringPrefix(), _src2) {
		return fmt.Errorf("field StringPrefix prefix rule failed, current value: %v", m.GetStringPrefix())
	}
	_src3 := "asd"
	if !strings.HasSuffix(m.GetStringSuffix(), _src3) {
		return fmt.Errorf("field StringSuffix suffix rule failed, current value: %v", m.GetStringSuffix())
	}
	_src4 := "asd"
	if !strings.Contains(m.GetStringContain(), _src4) {
		return fmt.Errorf("field StringContain contains rule failed, current value: %v", m.GetStringContain())
	}
	_src5 := "asd"
	if strings.Contains(m.GetStringNotContain(), _src5) {
		return fmt.Errorf("field StringNotContain not_contains rule failed, current value: %v", m.GetStringNotContain())
	}
	_src6 := []string{string("123"), string("456"), string("789")}

	var _exist bool
	for _, src := range _src6 {
		if m.GetStringIn() == src {
			_exist = true
			break
		}
	}
	if !_exist {
		return fmt.Errorf("field StringIn in rule failed, current value: %v", m.GetStringIn())
	}
	_src7 := []string{string("123"), string("456"), string("789")}

	for _, src := range _src7 {
		if m.GetStringNotIn() == src {
			return fmt.Errorf("field StringNotIn not_in rule failed, current value: %v", m.GetStringNotIn())
		}
	}
	return nil
}

func (m *BytesValidate) Validate() error {
	_src := []byte("asd")
	if !bytes.Equal(m.GetBytesConst(), _src) {
		return fmt.Errorf("field bytesConst not match const value, current value: %v", m.GetBytesConst())
	}
	if len(m.GetBytesMinSize()) < int(12) {
		return fmt.Errorf("field bytesMinSize min_len rule failed, current value: %d", len(m.GetBytesMinSize()))
	}
	if len(m.GetBytesMaxSize()) > int(12) {
		return fmt.Errorf("field bytesMaxSize max_len rule failed, current value: %d", len(m.GetBytesMaxSize()))
	}
	_src1 := "[0-9A-Za-z]+"
	if ok, _ := regexp.Match(string(_src1), m.GetBytesPattern()); !ok {
		return fmt.Errorf("field bytesPattern pattern rule failed, current value: %v", m.GetBytesPattern())
	}
	_src2 := []byte("asd")
	if !bytes.HasPrefix(m.GetBytesPrefix(), _src2) {
		return fmt.Errorf("field bytesPrefix prefix rule failed, current value: %v", m.GetBytesPrefix())
	}
	_src3 := []byte("asd")
	if !bytes.HasSuffix(m.GetBytesSuffix(), _src3) {
		return fmt.Errorf("field bytesSuffix suffix rule failed, current value: %v", m.GetBytesSuffix())
	}
	_src4 := []byte("asd")
	if !bytes.Contains(m.GetBytesContain(), _src4) {
		return fmt.Errorf("field bytesContain contains rule failed, current value: %v", m.GetBytesContain())
	}
	_src5 := []byte("asd")
	if bytes.Contains(m.GetBytesNotContain(), _src5) {
		return fmt.Errorf("field bytesNotContain not_contains rule failed, current value: %v", m.GetBytesNotContain())
	}
	_src6 := [][]byte{[]byte("123"), []byte("456"), []byte("789")}

	var _exist bool
	for _, src := range _src6 {
		if bytes.Equal(m.GetBytesIn(), src) {
			_exist = true
			break
		}
	}
	if !_exist {
		return fmt.Errorf("field bytesIn in rule failed, current value: %v", m.GetBytesIn())
	}
	_src7 := [][]byte{[]byte("123"), []byte("456"), []byte("789")}

	for _, src := range _src7 {
		if bytes.Equal(m.GetBytesNotIn(), src) {
			return fmt.Errorf("field bytesNotIn not_in rule failed, current value: %v", m.GetBytesNotIn())
		}
	}
	return nil
}

func (m *EnumValidate) Validate() error {
	_src := EnumType_TWEET
	if m.GetEnum1() != _src {
		return fmt.Errorf("field Enum1 const rule failed, current value: %v", m.GetEnum1())
	}
	_src1 := EnumType2_TWEET2
	if m.GetEnum2() != _src1 {
		return fmt.Errorf("field Enum2 const rule failed, current value: %v", m.GetEnum2())
	}
	_src2 := other.OtherEnumType_TWEET
	if m.GetEnum3() != _src2 {
		return fmt.Errorf("field Enum3 const rule failed, current value: %v", m.GetEnum3())
	}
	if _, ok := EnumType_name[int32(m.GetEnumDefineOnly())]; !ok {
		return fmt.Errorf("field EnumDefineOnly defined_only rule failed")
	}
	return nil
}

func (m *ListValidate) Validate() error {
	if len(m.GetListMinSize()) < int(12) {
		return fmt.Errorf("field ListMinSize MinLen rule failed, current value: %v", m.GetListMinSize())
	}
	if len(m.GetListMaxSize()) > int(11) {
		return fmt.Errorf("field ListMaxSize MaxLen rule failed, current value: %v", m.GetListMaxSize())
	}
	for i := 0; i < len(m.GetListBaseElem()); i++ {
		_elem := m.GetListBaseElem()[i]
		_src := "312"
		if _elem != _src {
			return fmt.Errorf("field _elem not match const value, current value: %v", _elem)
		}
	}
	for i := 0; i < len(m.GetListMsgElem()); i++ {
		_elem1 := m.GetListMsgElem()[i]
		if err := _elem1.Validate(); err != nil {
			return fmt.Errorf("filed _elem1 not valid, %w", err)
		}
	}
	for i := 0; i < len(m.GetListEnum()); i++ {
		_elem2 := m.GetListEnum()[i]
		_src1 := other.OtherEnumType_TWEET
		if _elem2 != _src1 {
			return fmt.Errorf("field _elem2 const rule failed, current value: %v", _elem2)
		}
	}
	for i := 0; i < len(m.GetListEnum2()); i++ {
		_elem3 := m.GetListEnum2()[i]
		_src2 := EnumType_TWEET
		if _elem3 != _src2 {
			return fmt.Errorf("field _elem3 const rule failed, current value: %v", _elem3)
		}
	}
	return nil
}

func (m *MapValidate) Validate() error {
	if len(m.GetMapISMinSize()) < int(10) {
		return fmt.Errorf("field MapISMinSize min_size rule failed, current value: %v", m.GetMapISMinSize())
	}
	if len(m.GetMapISMinSize()) > int(30) {
		return fmt.Errorf("field MapISMinSize max_size rule failed, current value: %v", m.GetMapISMinSize())
	}
	for _, v := range m.GetMapNoSparse() {
		if v == nil {
			return fmt.Errorf("field MapNoSparse no_sparse rule failed, current value: %v", m.GetMapNoSparse())
		}
	}
	for k := range m.GetMapISKeyValue() {
		if k <= int32(12) {
			return fmt.Errorf("field k gt rule failed, current value: %v", k)
		}
		if k != int32(123) {
			return fmt.Errorf("field k not match const value, current value: %v", k)
		}
	}
	for _, v := range m.GetMapISKeyValue() {
		_src := "asd"
		if v != _src {
			return fmt.Errorf("field v not match const value, current value: %v", v)
		}
		_src1 := "asd"
		if !strings.HasPrefix(v, _src1) {
			return fmt.Errorf("field v prefix rule failed, current value: %v", v)
		}
	}
	for _, v := range m.GetEnumType11() {
		_src2 := other.OtherEnumType_TWEET
		if v != _src2 {
			return fmt.Errorf("field v const rule failed, current value: %v", v)
		}
	}
	for _, v := range m.GetMapMsgKeyValue() {
		if err := v.Validate(); err != nil {
			return fmt.Errorf("filed v not valid, %w", err)
		}
	}
	return nil
}

func (m *FuncValidate) Validate() error {
	_src2 := time.Now().UnixNano()
	_src1 := _src2 + int64(122)
	_src := _src1 + int64(1000)

	if m.GetFunc1() <= int64(_src) {
		return fmt.Errorf("field Func1 gt rule failed, current value: %v", m.GetFunc1())
	}
	return nil
}

func (m *Example) Validate() error {
	_src := m.GetMaxLength()
	if fl := os.Getenv("FIXED_LENGTH"); fl != "" {
		if l, err := strconv.ParseInt(fl, 10, 0); err == nil {
			_src += l
		}
	}

	if len(m.GetMsg()) > int(_src) {
		return fmt.Errorf("field Msg max_len rule failed, current value: %d", len(m.GetMsg()))
	}
	return nil
}
